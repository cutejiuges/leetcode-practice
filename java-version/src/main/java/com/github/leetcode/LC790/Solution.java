package com.github.leetcode.LC790;

public class Solution {
    /*
    状态转移：
    dp[i][0]：这一列为空，只需要保留前面的状态，即 dp[i−1][1]；
    dp[i][1]：这一列为满，
        可以由 dp[i−1][0]（前一列空）加一个竖形覆盖当前列；
        可以由 dp[i−1][1]（前一列满）加一个横形覆盖当前列；
        可以由 dp[i−1][2] 或 dp[i−1][3]（前一列有缺口）加一个 LL 形补全当前列；
        也即，当前状态值 = 前 4 个状态的总和。
    dp[i][2]：这一列仅覆盖上面那个，
        可以由 dp[i−1][0]（前一列空）加一个 LL 形覆盖当前列的上半部分；
        可以由 dp[i−1][3]（前一列仅覆盖下半部分）加一个横形覆盖当前列的上半部分；
        也即，当前状态值 = dp[i−1][0] + dp[i−1][3]。
    dp[i][3]：这一列仅覆盖下面那个，类似于 dp[i][2]，但方向相反。
     */
    public int numTilings(int n) {
        int mod = (int) 1e9 + 7;
        // 定义dp[i][j]表示第i列的状态为j的方案数
        // 无须考虑前 i−1 列（含义为前 i−1 列已铺满）
        // j=0表示空，1表示满，2表示填上面那个，3表示填下面那个
        int[][] dp = new int[n+1][4];
        dp[1][0] = dp[1][1] = 1;
        for (int i = 1; i <= n; i++) {
            dp[i][0] = dp[i-1][1];
            int cur = 0;
            for (int j = 0; j < 4; j++) {
                cur = (cur + dp[i-1][j]) % mod;
            }
            dp[i][1] = cur;
            dp[i][2] = (dp[i-1][3]+dp[i-1][0]) % mod;
            dp[i][3] = (dp[i-1][2]+dp[i-1][0]) % mod;

        }
        return dp[n][1];
    }
}
